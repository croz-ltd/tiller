/*
 *    Copyright 2023 CROZ d.o.o, the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 */

import * as React from "react";

import { useCombobox } from "downshift";
import { Popover, positionMatchWidth } from "@reach/popover";

import { Input } from "@tiller-ds/form-elements";
import { useLabel } from "@tiller-ds/intl";
import { ComponentTokens, cx, TokenProps, useIcon, useTokens } from "@tiller-ds/theme";

import MenuHandleIcon from "./MenuHandleIcon";

export type TreeSelectProps<T> = {
  /**
   * Custom className given to the Field component which wraps this component.
   */
  className?: string;

  /**
   * Defines whether the component is disabled on render.
   */
  disabled?: boolean;

  /**
   * Passes the error to the Field component.
   */
  error?: React.ReactNode;

  /**
   * The help text displayed below the tree select field.
   */
  help?: React.ReactNode;

  /**
   * Tooltip icon and text (on icon hover) displayed on the right of the label.
   */
  tooltip?: React.ReactNode;

  /**
   * The label displayed above the tree select field.
   */
  label?: React.ReactNode;

  /**
   * The accessor value for the input field component (for validation, fetching, etc.).
   */
  name: string;

  /**
   * Options array handed over to the component (supports hierarchical ordering).
   */
  options: T[];

  /**
   * The placeholder displayed inside the field.
   */
  placeholder?: string;

  /**
   * Turns this field into a required field in the form. Only applies visual representation (* next to label),
   * still requires validation on frontend or backend to accompany this value if set to true.
   */
  required?: boolean;

  /**
   * The value of the field sent on submit and/or retrieved on component render.
   */
  value?: T | null;

  /**
   * A function that converts an item of type `T` into a string representation.
   * This string is displayed in the input field when a value is selected.
   *
   * **Primary Usage:**
   * - To display the selected item as text in the input field.
   *
   * **Secondary Usage:**
   * - This function is also used for filtering the options if the `filter` prop is not provided.
   *   When `filter` is undefined, the string generated by this function is compared
   *   with the user's search input to determine matches.
   *
   * @param item - The item of generic type `T` to be converted to a string.
   * @returns A string representation of the item to display in the input field.
   *
   * @example
   * // Example usage:
   * const itemToString = (item: Item) => `${item.name} ${item.surname}`;
   *
   * // Given an item:
   * const item = { name: 'John', surname: 'Doe' };
   *
   * // The result would be:
   * itemToString(item); // "John Doe"
   */
  itemToString: (item: T) => string;

  /**
   * A function that determines how options are filtered as the user types into the input field.
   *
   * **Primary Usage:**
   * - This function is called for each option in the dataset to determine if it matches the user's input.
   * - If provided, this function overrides the default filtering behavior that uses the `itemToString` prop.
   *
   * **When Not Provided:**
   * - If this prop is undefined, filtering falls back to using the `itemToString` function, which converts each option into a string for comparison.
   *
   * @param query - The user's input string used for filtering.
   * @param item - An item of generic type `T` representing a single option from the dataset.
   * @returns A boolean indicating whether the item matches the query.
   *
   * @example
   * // Example usage:
   * const filter = (query: string, option: Item) =>
   *   option.name.toLowerCase().includes(query.toLowerCase());
   *
   * // Given the input:
   * const query = "john";
   * const option = { name: "John Doe", surname: "Smith" };
   *
   * // The result would be:
   * filter(query, option); // true
   */
  filter?: (query: string, item: T) => boolean;

  /**
   * A unique identifier for testing purposes.
   * This identifier can be used in testing frameworks like Jest or Cypress to locate specific elements for testing.
   * It helps ensure that UI components are behaving as expected across different scenarios.
   * @type {string}
   * @example
   * // Usage:
   * <MyComponent data-testid="my-component" />
   * // In tests:
   * getByTestId('my-component');
   */
  "data-testid"?: string;

  /**
   * A function that generates a unique data-testid identifier for individual items.
   * The function accepts an item of type `T` and returns a string that can be
   * used as the `data-testid` for that item. By incorporating unique properties
   * of the item, it ensures that each element has a distinct identifier.
   *
   * // Example function:
   * const itemTestId = (item) => `list-item-${item.id}`;
   *
   * // Example test:
   * getByTestId('list-item-123');
   */
  "item-testid"?: (item: T) => string;
} & OptionProps<T> &
  SelectTokensProps;

type SelectTokensProps = {
  tokens?: ComponentTokens<"Select">;
};

type TreeSelectOptionsProps<T> = {
  options: T[];
  highlightedIndex: number;
  closeMenu: () => void;
  expanded?: boolean;
  testId?: (item: T) => string;
} & OptionProps<T>;

type TreeSelectOptionProps<T> = {
  option: T;
  index: number;
  highlightedIndex: number;
  closeMenu: () => void;
  initialExpanded?: boolean;
  testId?: (item: T) => string;
} & OptionProps<T> &
  TokenProps<"Select">;

type OptionProps<T> = {
  /**
   * Specifies the depth level of the current option within a nested or hierarchical structure.
   * Useful for rendering options with indentation or styling based on their nesting level.
   *
   * @default 0 - If not provided, the level is assumed to be the top level (0).
   *
   * @example
   * const options = [
   *   { label: "Parent", level: 0 },
   *   { label: "Child", level: 1 },
   * ];
   */
  level?: number;

  /**
   * A function that retrieves the display label for a given option item.
   * The returned value will be rendered as the visible label in the dropdown UI.
   *
   * @param item - An option of type `T` for which the label is needed.
   * @returns A React node that represents the display content (e.g., string, JSX).
   *
   * @example
   * const getOptionLabel = (item) => <span>{item.name}</span>;
   */
  getOptionLabel: (item: T) => React.ReactNode;

  /**
   * A function that retrieves the display label for a selected value.
   * This is typically used to display the selected value in an input field or a summary view.
   *
   * If not provided, the `getOptionLabel` function can be used as a fallback.
   *
   * @param item - An option of type `T` for which the value label is needed.
   * @returns A React node that represents the display content of the value.
   *
   * @example
   * const getValueLabel = (item) => item.shortName || item.name;
   */
  getValueLabel?: (item: T) => React.ReactNode;

  /**
   * A function that retrieves the child items of a given option, enabling support for nested or hierarchical data structures.
   *
   * @param item - An option of type `T` for which child items are needed.
   * @returns An array of items of type `T` representing the children of the current option.
   *
   * @example
   * const getItems = (item) => item.children || [];
   */
  getItems: (item: T) => T[];

  /**
   * A callback function that is triggered when an option is selected or changed.
   * This function allows you to handle the selected option or reset the selection.
   *
   * @param item - The selected option of type `T`, or `undefined` if the selection is cleared.
   *
   * @example
   * const onChange = (item) => {
   *   console.log("Selected:", item);
   * };
   */
  onChange: (item: T | undefined) => void;
};

const levelClasses = ["", "pl-2", "pl-4", "pl-6", "pl-8", "pl-10", "pl-12"];

export default function TreeSelect<T>({
  name,
  value,
  label,
  help,
  error,
  placeholder,
  disabled,
  options,
  getOptionLabel,
  getValueLabel,
  itemToString,
  filter,
  getItems,
  className,
  required,
  onChange,
  ...props
}: TreeSelectProps<T>) {
  const tokens = useTokens("TreeSelect", props.tokens);

  const id = `input-${name}`;

  const menuRef = React.useRef<HTMLElement>(null);
  const inputRef = React.useRef<HTMLInputElement>(null);

  const clearIcon = useIcon("dismiss", undefined, { size: 3 });

  const safeItemToString = (value: T | null | undefined) => (value ? itemToString(value) : "");
  const initialInputValue = value ? safeItemToString(value) : "";

  const [searchMatch, setSearchMatch] = React.useState<{ count: number; match?: T }>({ count: 0 });
  const [filteredOptions, setFilteredOptions] = React.useState<T[]>(options);

  const {
    getInputProps,
    getComboboxProps,
    getMenuProps,
    isOpen,
    reset,
    closeMenu,
    toggleMenu,
    inputValue,
    setInputValue,
    highlightedIndex,
  } = useCombobox<T>({
    items: filteredOptions,
    labelId: id,
    itemToString: safeItemToString,
    initialInputValue,
    onIsOpenChange: (state) => {
      setSearchMatch({ count: 0 });
      if (state.isOpen) {
        setFilteredOptions(filterItems(options, String(state.inputValue)));
      }
    },
    onInputValueChange: (state) => {
      setSearchMatch({ count: 0 });
      setFilteredOptions(filterItems(options, String(state.inputValue)));
    },
    onStateChange: (state) => {
      const { type } = state;
      if (type === useCombobox.stateChangeTypes.InputBlur) {
        if (searchMatch.count === 0 || searchMatch.count > 1) {
          onChange(undefined);
          setInputValue("");
        } else if (searchMatch.count === 1 && searchMatch.match) {
          onChange(searchMatch.match);
          setInputValue(itemToString(searchMatch.match));
        }
      }
    },
  });

  const filterItems = (searchTree: T[], searchTerm: string): T[] => {
    let matchCount = 0;
    let singleMatch: T | undefined = undefined;

    const filterTree = (tree: T[]): T[] => {
      return tree
        .map((option) => {
          const items = getItems(option);

          if (items && items.length > 0) {
            const filteredItems = filterTree(items);

            if (filteredItems.length > 0) {
              return { ...option, items: filteredItems };
            }
          }

          const optionMatches = filter
            ? filter(searchTerm, option)
            : itemToString(option).toLowerCase().includes(searchTerm.toLowerCase());

          if (optionMatches) {
            if (items.length === 0) {
              matchCount += 1;
              if (matchCount === 1) {
                singleMatch = option;
              } else {
                singleMatch = undefined;
              }
            }
            return option;
          }

          return null;
        })
        .filter((result) => result !== null) as T[];
    };

    if (searchTerm.trim() === "") {
      setSearchMatch({ count: 0, match: undefined });
      return searchTree;
    }

    const filteredTree = filterTree(searchTree);
    setSearchMatch({ count: matchCount, match: singleMatch });

    return filteredTree;
  };

  const clearClassName = cx(
    { [tokens.Clear.active]: !disabled },
    tokens.Clear.base.padding,
    tokens.Clear.base.margin,
    "flex align-center",
  );
  const listClassName = cx(tokens.List.master, tokens.List.borderRadius, tokens.List.boxShadow, { invisible: !isOpen });
  const listInnerClassName = cx(
    tokens.List.inner.base,
    tokens.List.inner.margin,
    tokens.List.inner.borderRadius,
    tokens.List.inner.backgroundColor,
    tokens.List.inner.boxShadow,
    tokens.List.inner.outline,
  );
  const itemClassName = cx(
    tokens.Item.base.master,
    tokens.Item.base.padding,
    tokens.Item.base.fontSize,
    tokens.Item.base.lineHeight,
    tokens.Item.base.color,
  );
  const selectClassName = cx(
    tokens.Select.base,
    { [tokens.Select.active]: !disabled },
    { [tokens.Select.disabled]: disabled },
  );

  const valueLabelClassName = cx(tokens.ValueLabel.base, { [tokens.ValueLabel.disabled]: disabled });

  const onValueChange = (item: T | undefined) => {
    if (disabled) return;
    inputRef.current?.focus();
    onChange(item);

    setInputValue(item ? itemToString(item) : "");
  };

  const clear = (event: React.MouseEvent<unknown>) => {
    event.stopPropagation();

    onChange(undefined);
    reset();

    setInputValue("");
    inputRef.current?.focus();
  };

  const onInputClick = () => {
    toggleMenu();
    inputRef.current?.focus();
  };

  const noResultsText = useLabel("treeSelectNoResults", "No results for:");
  const noResultsPlaceholderContent = inputValue?.length > 0 ? `${noResultsText} ${inputValue}` : null;

  return (
    <>
      <Input
        ref={inputRef}
        className={className}
        id={id}
        data-testid={props["data-testid"] ?? id}
        label={label}
        help={help}
        tooltip={props.tooltip}
        placeholder={placeholder}
        required={required}
        error={error}
        name={name}
        disabled={disabled}
        autoComplete="off"
        inlineTrailingIcon={
          <div className="flex items-center justify-between">
            {value && getValueLabel && <div className={valueLabelClassName}>{getValueLabel(value)}</div>}
            <div className="flex flex-row items-center">
              {!disabled && value && (
                <div
                  className={clearClassName}
                  onClick={clear}
                  data-testid={props["data-testid"] && `${props["data-testid"]}-clear`}
                >
                  {clearIcon}
                </div>
              )}
              {value && (
                <div className={tokens.Separator.container}>
                  <div className={tokens.Separator.inner}>&nbsp;</div>
                </div>
              )}
              <div className={selectClassName} onClick={() => !disabled && onInputClick()}>
                <MenuHandleIcon />
              </div>
            </div>
          </div>
        }
        {...getInputProps({
          id: id,
          ref: inputRef,
          refKey: "inputRef",
          onClick: onInputClick,
          value: inputValue,
        })}
        {...getComboboxProps({}, { suppressRefError: true })}
      />
      <Popover
        className="z-50"
        targetRef={inputRef}
        position={positionMatchWidth}
        {...getMenuProps({ ref: menuRef }, { suppressRefError: true })}
      >
        {isOpen && !disabled && (
          <div className={listClassName}>
            <div className={listInnerClassName}>
              {filteredOptions.length === 0 ? (
                <div className={itemClassName}>{noResultsPlaceholderContent}</div>
              ) : (
                <TreeSelectOptions
                  options={filteredOptions}
                  getOptionLabel={getOptionLabel}
                  getItems={getItems}
                  onChange={onValueChange}
                  closeMenu={closeMenu}
                  expanded={inputValue.length > 0}
                  highlightedIndex={highlightedIndex}
                  testId={props["item-testid"]}
                />
              )}
            </div>
          </div>
        )}
      </Popover>
    </>
  );
}

function TreeSelectOptions<T>({ options, expanded, highlightedIndex, testId, ...props }: TreeSelectOptionsProps<T>) {
  return (
    <>
      {options.map((option, index) => (
        <TreeSelectOption
          key={index}
          index={index}
          {...props}
          highlightedIndex={highlightedIndex}
          option={option}
          initialExpanded={expanded}
          testId={testId}
        />
      ))}
    </>
  );
}

function TreeSelectOption<T>({
  level = 0,
  option,
  getOptionLabel,
  getItems,
  onChange,
  closeMenu,
  initialExpanded = false,
  index,
  highlightedIndex,
  testId,
  ...props
}: TreeSelectOptionProps<T>) {
  const tokens = useTokens("TreeSelect", props.tokens);
  const [expanded, setExpanded] = React.useState(() => initialExpanded);

  React.useEffect(() => {
    setExpanded(initialExpanded);
  }, [initialExpanded]);

  const childOptions = getItems(option);

  const onItemClick = () => {
    if (childOptions.length > 0) {
      setExpanded(!expanded);
    } else {
      onChange(option);
      closeMenu();
    }
  };

  const iconProps = { className: "pr-2", size: 3 };
  const openExpanderIcon = useIcon("openExpander", undefined, iconProps);
  const closeExpanderIcon = useIcon("closeExpander", undefined, iconProps);

  const icon = expanded ? closeExpanderIcon : openExpanderIcon;

  const itemClassName = cx(
    tokens.Item.base.master,
    tokens.Item.base.padding,
    tokens.Item.base.fontSize,
    tokens.Item.base.lineHeight,
    tokens.Item.base.color,
    tokens.Item.base.hover,
  );

  const innerItemClassName = cx("flex items-center", levelClasses[level]);
  const labelClassName = cx({
    "pl-6": childOptions.length === 0,
    "pl-1": childOptions.length > 0,
  });

  return (
    <div>
      <div className={itemClassName} onClick={onItemClick} data-testid={testId && testId(option)}>
        <div className={levelClasses[level]}>
          <div className={innerItemClassName}>
            {childOptions.length > 0 && icon}
            <div className={labelClassName}>{getOptionLabel(option)}</div>
          </div>
        </div>
      </div>
      {expanded && childOptions.length > 0 && (
        <TreeSelectOptions
          level={level + 1}
          options={childOptions}
          getOptionLabel={getOptionLabel}
          getItems={getItems}
          onChange={onChange}
          closeMenu={closeMenu}
          expanded={initialExpanded}
          highlightedIndex={highlightedIndex}
          testId={testId}
        />
      )}
    </div>
  );
}
